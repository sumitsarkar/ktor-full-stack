/*
 * This file is generated by jOOQ.
 */
package me.sumit.uptime.database.generated.routines.references


import java.time.LocalDate
import java.time.LocalDateTime
import java.time.OffsetDateTime

import me.sumit.uptime.database.generated.routines.AddCompressionPolicy
import me.sumit.uptime.database.generated.routines.AddContinuousAggregatePolicy
import me.sumit.uptime.database.generated.routines.AddJob
import me.sumit.uptime.database.generated.routines.AddReorderPolicy
import me.sumit.uptime.database.generated.routines.AddRetentionPolicy
import me.sumit.uptime.database.generated.routines.ApproximateRowCount
import me.sumit.uptime.database.generated.routines.AttachTablespace
import me.sumit.uptime.database.generated.routines.CompressChunk
import me.sumit.uptime.database.generated.routines.DecompressChunk
import me.sumit.uptime.database.generated.routines.DeleteDataNode
import me.sumit.uptime.database.generated.routines.DeleteJob
import me.sumit.uptime.database.generated.routines.DetachDataNode
import me.sumit.uptime.database.generated.routines.DetachTablespace
import me.sumit.uptime.database.generated.routines.DetachTablespaces
import me.sumit.uptime.database.generated.routines.First
import me.sumit.uptime.database.generated.routines.GetTelemetryReport
import me.sumit.uptime.database.generated.routines.Histogram
import me.sumit.uptime.database.generated.routines.HypertableIndexSize
import me.sumit.uptime.database.generated.routines.HypertableSize
import me.sumit.uptime.database.generated.routines.Interpolate1
import me.sumit.uptime.database.generated.routines.Interpolate2
import me.sumit.uptime.database.generated.routines.Interpolate3
import me.sumit.uptime.database.generated.routines.Interpolate4
import me.sumit.uptime.database.generated.routines.Interpolate5
import me.sumit.uptime.database.generated.routines.Last
import me.sumit.uptime.database.generated.routines.Locf
import me.sumit.uptime.database.generated.routines.MoveChunk
import me.sumit.uptime.database.generated.routines.RecompressChunk
import me.sumit.uptime.database.generated.routines.RemoveCompressionPolicy
import me.sumit.uptime.database.generated.routines.RemoveContinuousAggregatePolicy
import me.sumit.uptime.database.generated.routines.RemoveReorderPolicy
import me.sumit.uptime.database.generated.routines.RemoveRetentionPolicy
import me.sumit.uptime.database.generated.routines.ReorderChunk
import me.sumit.uptime.database.generated.routines.SetAdaptiveChunking
import me.sumit.uptime.database.generated.routines.SetChunkTimeInterval
import me.sumit.uptime.database.generated.routines.SetIntegerNowFunc
import me.sumit.uptime.database.generated.routines.SetNumberPartitions
import me.sumit.uptime.database.generated.routines.SetReplicationFactor
import me.sumit.uptime.database.generated.routines.TimeBucket1
import me.sumit.uptime.database.generated.routines.TimeBucket10
import me.sumit.uptime.database.generated.routines.TimeBucket11
import me.sumit.uptime.database.generated.routines.TimeBucket12
import me.sumit.uptime.database.generated.routines.TimeBucket13
import me.sumit.uptime.database.generated.routines.TimeBucket14
import me.sumit.uptime.database.generated.routines.TimeBucket15
import me.sumit.uptime.database.generated.routines.TimeBucket2
import me.sumit.uptime.database.generated.routines.TimeBucket3
import me.sumit.uptime.database.generated.routines.TimeBucket4
import me.sumit.uptime.database.generated.routines.TimeBucket5
import me.sumit.uptime.database.generated.routines.TimeBucket6
import me.sumit.uptime.database.generated.routines.TimeBucket7
import me.sumit.uptime.database.generated.routines.TimeBucket8
import me.sumit.uptime.database.generated.routines.TimeBucket9
import me.sumit.uptime.database.generated.routines.TimeBucketGapfill1
import me.sumit.uptime.database.generated.routines.TimeBucketGapfill2
import me.sumit.uptime.database.generated.routines.TimeBucketGapfill3
import me.sumit.uptime.database.generated.routines.TimeBucketGapfill4
import me.sumit.uptime.database.generated.routines.TimeBucketGapfill5
import me.sumit.uptime.database.generated.routines.TimeBucketGapfill6
import me.sumit.uptime.database.generated.routines.TimescaledbFdwHandler
import me.sumit.uptime.database.generated.routines.TimescaledbFdwValidator
import me.sumit.uptime.database.generated.routines.TimescaledbPostRestore
import me.sumit.uptime.database.generated.routines.TimescaledbPreRestore
import me.sumit.uptime.database.generated.tables.AddDataNode
import me.sumit.uptime.database.generated.tables.AddDimension
import me.sumit.uptime.database.generated.tables.AlterJob
import me.sumit.uptime.database.generated.tables.AttachDataNode
import me.sumit.uptime.database.generated.tables.ChunkCompressionStats
import me.sumit.uptime.database.generated.tables.ChunksDetailedSize
import me.sumit.uptime.database.generated.tables.CreateDistributedHypertable
import me.sumit.uptime.database.generated.tables.CreateDistributedRestorePoint
import me.sumit.uptime.database.generated.tables.CreateHypertable
import me.sumit.uptime.database.generated.tables.DropChunks
import me.sumit.uptime.database.generated.tables.HypertableCompressionStats
import me.sumit.uptime.database.generated.tables.HypertableDetailedSize
import me.sumit.uptime.database.generated.tables.ShowChunks
import me.sumit.uptime.database.generated.tables.ShowTablespaces
import me.sumit.uptime.database.generated.tables.records.AddDataNodeRecord
import me.sumit.uptime.database.generated.tables.records.AddDimensionRecord
import me.sumit.uptime.database.generated.tables.records.AlterJobRecord
import me.sumit.uptime.database.generated.tables.records.AttachDataNodeRecord
import me.sumit.uptime.database.generated.tables.records.ChunkCompressionStatsRecord
import me.sumit.uptime.database.generated.tables.records.ChunksDetailedSizeRecord
import me.sumit.uptime.database.generated.tables.records.CreateDistributedHypertableRecord
import me.sumit.uptime.database.generated.tables.records.CreateDistributedRestorePointRecord
import me.sumit.uptime.database.generated.tables.records.CreateHypertableRecord
import me.sumit.uptime.database.generated.tables.records.DropChunksRecord
import me.sumit.uptime.database.generated.tables.records.HypertableCompressionStatsRecord
import me.sumit.uptime.database.generated.tables.records.HypertableDetailedSizeRecord
import me.sumit.uptime.database.generated.tables.records.ShowChunksRecord
import me.sumit.uptime.database.generated.tables.records.ShowTablespacesRecord

import org.jooq.AggregateFunction
import org.jooq.Configuration
import org.jooq.Field
import org.jooq.Record
import org.jooq.Result
import org.jooq.types.YearToSecond


@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addCompressionPolicy(
      configuration: Configuration
    , hypertable: Any?
    , compressAfter: Any?
    , ifNotExists: Boolean?
): Int? {
    val f = AddCompressionPolicy()
    f.setHypertable(hypertable)
    f.setCompressAfter(compressAfter)
    f.setIfNotExists(ifNotExists)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addCompressionPolicy(
      hypertable: Any?
    , compressAfter: Any?
    , ifNotExists: Boolean?
): Field<Int?> {
    val f = AddCompressionPolicy()
    f.setHypertable(hypertable)
    f.setCompressAfter(compressAfter)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addCompressionPolicy(
      hypertable: Field<Any?>
    , compressAfter: Field<Any?>
    , ifNotExists: Field<Boolean?>
): Field<Int?> {
    val f = AddCompressionPolicy()
    f.setHypertable(hypertable)
    f.setCompressAfter(compressAfter)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addContinuousAggregatePolicy(
      configuration: Configuration
    , continuousAggregate: Any?
    , startOffset: Any?
    , endOffset: Any?
    , scheduleInterval: YearToSecond?
    , ifNotExists: Boolean?
): Int? {
    val f = AddContinuousAggregatePolicy()
    f.setContinuousAggregate(continuousAggregate)
    f.setStartOffset(startOffset)
    f.setEndOffset(endOffset)
    f.setScheduleInterval(scheduleInterval)
    f.setIfNotExists(ifNotExists)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addContinuousAggregatePolicy(
      continuousAggregate: Any?
    , startOffset: Any?
    , endOffset: Any?
    , scheduleInterval: YearToSecond?
    , ifNotExists: Boolean?
): Field<Int?> {
    val f = AddContinuousAggregatePolicy()
    f.setContinuousAggregate(continuousAggregate)
    f.setStartOffset(startOffset)
    f.setEndOffset(endOffset)
    f.setScheduleInterval(scheduleInterval)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addContinuousAggregatePolicy(
      continuousAggregate: Field<Any?>
    , startOffset: Field<Any?>
    , endOffset: Field<Any?>
    , scheduleInterval: Field<YearToSecond?>
    , ifNotExists: Field<Boolean?>
): Field<Int?> {
    val f = AddContinuousAggregatePolicy()
    f.setContinuousAggregate(continuousAggregate)
    f.setStartOffset(startOffset)
    f.setEndOffset(endOffset)
    f.setScheduleInterval(scheduleInterval)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}

/**
 * Call <code>public.add_job</code>
 */
fun addJob(
      configuration: Configuration
    , proc: String?
    , scheduleInterval: YearToSecond?
    , config: String?
    , initialStart: OffsetDateTime?
    , scheduled: Boolean?
): Int? {
    val f = AddJob()
    f.setProc(proc)
    f.setScheduleInterval(scheduleInterval)
    f.setConfig(config)
    f.setInitialStart(initialStart)
    f.setScheduled(scheduled)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.add_job</code> as a field.
 */
fun addJob(
      proc: String?
    , scheduleInterval: YearToSecond?
    , config: String?
    , initialStart: OffsetDateTime?
    , scheduled: Boolean?
): Field<Int?> {
    val f = AddJob()
    f.setProc(proc)
    f.setScheduleInterval(scheduleInterval)
    f.setConfig(config)
    f.setInitialStart(initialStart)
    f.setScheduled(scheduled)

    return f.asField()
}

/**
 * Get <code>public.add_job</code> as a field.
 */
fun addJob(
      proc: Field<String?>
    , scheduleInterval: Field<YearToSecond?>
    , config: Field<String?>
    , initialStart: Field<OffsetDateTime?>
    , scheduled: Field<Boolean?>
): Field<Int?> {
    val f = AddJob()
    f.setProc(proc)
    f.setScheduleInterval(scheduleInterval)
    f.setConfig(config)
    f.setInitialStart(initialStart)
    f.setScheduled(scheduled)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addReorderPolicy(
      configuration: Configuration
    , hypertable: Any?
    , indexName: String?
    , ifNotExists: Boolean?
): Int? {
    val f = AddReorderPolicy()
    f.setHypertable(hypertable)
    f.setIndexName(indexName)
    f.setIfNotExists(ifNotExists)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addReorderPolicy(
      hypertable: Any?
    , indexName: String?
    , ifNotExists: Boolean?
): Field<Int?> {
    val f = AddReorderPolicy()
    f.setHypertable(hypertable)
    f.setIndexName(indexName)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addReorderPolicy(
      hypertable: Field<Any?>
    , indexName: Field<String?>
    , ifNotExists: Field<Boolean?>
): Field<Int?> {
    val f = AddReorderPolicy()
    f.setHypertable(hypertable)
    f.setIndexName(indexName)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addRetentionPolicy(
      configuration: Configuration
    , relation: Any?
    , dropAfter: Any?
    , ifNotExists: Boolean?
): Int? {
    val f = AddRetentionPolicy()
    f.setRelation(relation)
    f.setDropAfter(dropAfter)
    f.setIfNotExists(ifNotExists)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addRetentionPolicy(
      relation: Any?
    , dropAfter: Any?
    , ifNotExists: Boolean?
): Field<Int?> {
    val f = AddRetentionPolicy()
    f.setRelation(relation)
    f.setDropAfter(dropAfter)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addRetentionPolicy(
      relation: Field<Any?>
    , dropAfter: Field<Any?>
    , ifNotExists: Field<Boolean?>
): Field<Int?> {
    val f = AddRetentionPolicy()
    f.setRelation(relation)
    f.setDropAfter(dropAfter)
    f.setIfNotExists(ifNotExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun approximateRowCount(
      configuration: Configuration
    , relation: Any?
): Long? {
    val f = ApproximateRowCount()
    f.setRelation(relation)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun approximateRowCount(
      relation: Any?
): Field<Long?> {
    val f = ApproximateRowCount()
    f.setRelation(relation)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun approximateRowCount(
      relation: Field<Any?>
): Field<Long?> {
    val f = ApproximateRowCount()
    f.setRelation(relation)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun attachTablespace(
      configuration: Configuration
    , tablespace: String?
    , hypertable: Any?
    , ifNotAttached: Boolean?
): Unit {
    val p = AttachTablespace()
    p.setTablespace(tablespace)
    p.setHypertable(hypertable)
    p.setIfNotAttached(ifNotAttached)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun compressChunk(
      configuration: Configuration
    , uncompressedChunk: Any?
    , ifNotCompressed: Boolean?
): Any? {
    val f = CompressChunk()
    f.setUncompressedChunk(uncompressedChunk)
    f.setIfNotCompressed(ifNotCompressed)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun compressChunk(
      uncompressedChunk: Any?
    , ifNotCompressed: Boolean?
): Field<Any?> {
    val f = CompressChunk()
    f.setUncompressedChunk(uncompressedChunk)
    f.setIfNotCompressed(ifNotCompressed)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun compressChunk(
      uncompressedChunk: Field<Any?>
    , ifNotCompressed: Field<Boolean?>
): Field<Any?> {
    val f = CompressChunk()
    f.setUncompressedChunk(uncompressedChunk)
    f.setIfNotCompressed(ifNotCompressed)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun decompressChunk(
      configuration: Configuration
    , uncompressedChunk: Any?
    , ifCompressed: Boolean?
): Any? {
    val f = DecompressChunk()
    f.setUncompressedChunk(uncompressedChunk)
    f.setIfCompressed(ifCompressed)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun decompressChunk(
      uncompressedChunk: Any?
    , ifCompressed: Boolean?
): Field<Any?> {
    val f = DecompressChunk()
    f.setUncompressedChunk(uncompressedChunk)
    f.setIfCompressed(ifCompressed)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun decompressChunk(
      uncompressedChunk: Field<Any?>
    , ifCompressed: Field<Boolean?>
): Field<Any?> {
    val f = DecompressChunk()
    f.setUncompressedChunk(uncompressedChunk)
    f.setIfCompressed(ifCompressed)

    return f.asField()
}

/**
 * Call <code>public.delete_data_node</code>
 */
fun deleteDataNode(
      configuration: Configuration
    , nodeName: String?
    , ifExists: Boolean?
    , force: Boolean?
    , repartition: Boolean?
): Boolean? {
    val f = DeleteDataNode()
    f.setNodeName(nodeName)
    f.setIfExists(ifExists)
    f.setForce(force)
    f.setRepartition(repartition)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.delete_data_node</code> as a field.
 */
fun deleteDataNode(
      nodeName: String?
    , ifExists: Boolean?
    , force: Boolean?
    , repartition: Boolean?
): Field<Boolean?> {
    val f = DeleteDataNode()
    f.setNodeName(nodeName)
    f.setIfExists(ifExists)
    f.setForce(force)
    f.setRepartition(repartition)

    return f.asField()
}

/**
 * Get <code>public.delete_data_node</code> as a field.
 */
fun deleteDataNode(
      nodeName: Field<String?>
    , ifExists: Field<Boolean?>
    , force: Field<Boolean?>
    , repartition: Field<Boolean?>
): Field<Boolean?> {
    val f = DeleteDataNode()
    f.setNodeName(nodeName)
    f.setIfExists(ifExists)
    f.setForce(force)
    f.setRepartition(repartition)

    return f.asField()
}

/**
 * Call <code>public.delete_job</code>
 */
fun deleteJob(
      configuration: Configuration
    , jobId: Int?
): Unit {
    val p = DeleteJob()
    p.setJobId(jobId)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachDataNode(
      configuration: Configuration
    , nodeName: String?
    , hypertable: Any?
    , ifAttached: Boolean?
    , force: Boolean?
    , repartition: Boolean?
): Int? {
    val f = DetachDataNode()
    f.setNodeName(nodeName)
    f.setHypertable(hypertable)
    f.setIfAttached(ifAttached)
    f.setForce(force)
    f.setRepartition(repartition)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachDataNode(
      nodeName: String?
    , hypertable: Any?
    , ifAttached: Boolean?
    , force: Boolean?
    , repartition: Boolean?
): Field<Int?> {
    val f = DetachDataNode()
    f.setNodeName(nodeName)
    f.setHypertable(hypertable)
    f.setIfAttached(ifAttached)
    f.setForce(force)
    f.setRepartition(repartition)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachDataNode(
      nodeName: Field<String?>
    , hypertable: Field<Any?>
    , ifAttached: Field<Boolean?>
    , force: Field<Boolean?>
    , repartition: Field<Boolean?>
): Field<Int?> {
    val f = DetachDataNode()
    f.setNodeName(nodeName)
    f.setHypertable(hypertable)
    f.setIfAttached(ifAttached)
    f.setForce(force)
    f.setRepartition(repartition)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachTablespace(
      configuration: Configuration
    , tablespace: String?
    , hypertable: Any?
    , ifAttached: Boolean?
): Int? {
    val f = DetachTablespace()
    f.setTablespace(tablespace)
    f.setHypertable(hypertable)
    f.setIfAttached(ifAttached)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachTablespace(
      tablespace: String?
    , hypertable: Any?
    , ifAttached: Boolean?
): Field<Int?> {
    val f = DetachTablespace()
    f.setTablespace(tablespace)
    f.setHypertable(hypertable)
    f.setIfAttached(ifAttached)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachTablespace(
      tablespace: Field<String?>
    , hypertable: Field<Any?>
    , ifAttached: Field<Boolean?>
): Field<Int?> {
    val f = DetachTablespace()
    f.setTablespace(tablespace)
    f.setHypertable(hypertable)
    f.setIfAttached(ifAttached)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachTablespaces(
      configuration: Configuration
    , hypertable: Any?
): Int? {
    val f = DetachTablespaces()
    f.setHypertable(hypertable)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachTablespaces(
      hypertable: Any?
): Field<Int?> {
    val f = DetachTablespaces()
    f.setHypertable(hypertable)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun detachTablespaces(
      hypertable: Field<Any?>
): Field<Int?> {
    val f = DetachTablespaces()
    f.setHypertable(hypertable)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun first(
      __1: Any?
    , __2: Any?
): AggregateFunction<Any?> {
    val f = First()
    f.set__1(__1)
    f.set__2(__2)

    return f.asAggregateFunction()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun first(
      __1: Field<Any?>
    , __2: Field<Any?>
): AggregateFunction<Any?> {
    val f = First()
    f.set__1(__1)
    f.set__2(__2)

    return f.asAggregateFunction()
}

/**
 * Call <code>public.get_telemetry_report</code>
 */
fun getTelemetryReport(
      configuration: Configuration
    , alwaysDisplayReport: Boolean?
): String? {
    val f = GetTelemetryReport()
    f.setAlwaysDisplayReport(alwaysDisplayReport)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.get_telemetry_report</code> as a field.
 */
fun getTelemetryReport(
      alwaysDisplayReport: Boolean?
): Field<String?> {
    val f = GetTelemetryReport()
    f.setAlwaysDisplayReport(alwaysDisplayReport)

    return f.asField()
}

/**
 * Get <code>public.get_telemetry_report</code> as a field.
 */
fun getTelemetryReport(
      alwaysDisplayReport: Field<Boolean?>
): Field<String?> {
    val f = GetTelemetryReport()
    f.setAlwaysDisplayReport(alwaysDisplayReport)

    return f.asField()
}

/**
 * Get <code>public.histogram</code> as a field.
 */
fun histogram(
      __1: Double?
    , __2: Double?
    , __3: Double?
    , __4: Int?
): AggregateFunction<Array<Int?>?> {
    val f = Histogram()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    return f.asAggregateFunction()
}

/**
 * Get <code>public.histogram</code> as a field.
 */
fun histogram(
      __1: Field<Double?>
    , __2: Field<Double?>
    , __3: Field<Double?>
    , __4: Field<Int?>
): AggregateFunction<Array<Int?>?> {
    val f = Histogram()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    return f.asAggregateFunction()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableIndexSize(
      configuration: Configuration
    , indexName: Any?
): Long? {
    val f = HypertableIndexSize()
    f.setIndexName(indexName)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableIndexSize(
      indexName: Any?
): Field<Long?> {
    val f = HypertableIndexSize()
    f.setIndexName(indexName)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableIndexSize(
      indexName: Field<Any?>
): Field<Long?> {
    val f = HypertableIndexSize()
    f.setIndexName(indexName)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableSize(
      configuration: Configuration
    , hypertable: Any?
): Long? {
    val f = HypertableSize()
    f.setHypertable(hypertable)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableSize(
      hypertable: Any?
): Field<Long?> {
    val f = HypertableSize()
    f.setHypertable(hypertable)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableSize(
      hypertable: Field<Any?>
): Field<Long?> {
    val f = HypertableSize()
    f.setHypertable(hypertable)

    return f.asField()
}

/**
 * Call <code>public.interpolate</code>
 */
fun interpolate1(
      configuration: Configuration
    , value: Short?
    , prev: Record?
    , next: Record?
): Short? {
    val f = Interpolate1()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate1(
      value: Short?
    , prev: Record?
    , next: Record?
): Field<Short?> {
    val f = Interpolate1()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate1(
      value: Field<Short?>
    , prev: Field<Record?>
    , next: Field<Record?>
): Field<Short?> {
    val f = Interpolate1()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Call <code>public.interpolate</code>
 */
fun interpolate2(
      configuration: Configuration
    , value: Int?
    , prev: Record?
    , next: Record?
): Int? {
    val f = Interpolate2()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate2(
      value: Int?
    , prev: Record?
    , next: Record?
): Field<Int?> {
    val f = Interpolate2()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate2(
      value: Field<Int?>
    , prev: Field<Record?>
    , next: Field<Record?>
): Field<Int?> {
    val f = Interpolate2()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Call <code>public.interpolate</code>
 */
fun interpolate3(
      configuration: Configuration
    , value: Long?
    , prev: Record?
    , next: Record?
): Long? {
    val f = Interpolate3()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate3(
      value: Long?
    , prev: Record?
    , next: Record?
): Field<Long?> {
    val f = Interpolate3()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate3(
      value: Field<Long?>
    , prev: Field<Record?>
    , next: Field<Record?>
): Field<Long?> {
    val f = Interpolate3()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Call <code>public.interpolate</code>
 */
fun interpolate4(
      configuration: Configuration
    , value: Float?
    , prev: Record?
    , next: Record?
): Float? {
    val f = Interpolate4()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate4(
      value: Float?
    , prev: Record?
    , next: Record?
): Field<Float?> {
    val f = Interpolate4()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate4(
      value: Field<Float?>
    , prev: Field<Record?>
    , next: Field<Record?>
): Field<Float?> {
    val f = Interpolate4()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Call <code>public.interpolate</code>
 */
fun interpolate5(
      configuration: Configuration
    , value: Double?
    , prev: Record?
    , next: Record?
): Double? {
    val f = Interpolate5()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate5(
      value: Double?
    , prev: Record?
    , next: Record?
): Field<Double?> {
    val f = Interpolate5()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}

/**
 * Get <code>public.interpolate</code> as a field.
 */
fun interpolate5(
      value: Field<Double?>
    , prev: Field<Record?>
    , next: Field<Record?>
): Field<Double?> {
    val f = Interpolate5()
    f.setValue(value)
    f.setPrev(prev)
    f.setNext(next)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun last(
      __1: Any?
    , __2: Any?
): AggregateFunction<Any?> {
    val f = Last()
    f.set__1(__1)
    f.set__2(__2)

    return f.asAggregateFunction()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun last(
      __1: Field<Any?>
    , __2: Field<Any?>
): AggregateFunction<Any?> {
    val f = Last()
    f.set__1(__1)
    f.set__2(__2)

    return f.asAggregateFunction()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun locf(
      configuration: Configuration
    , value: Any?
    , prev: Any?
    , treatNullAsMissing: Boolean?
): Any? {
    val f = Locf()
    f.setValue(value)
    f.setPrev(prev)
    f.setTreatNullAsMissing(treatNullAsMissing)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun locf(
      value: Any?
    , prev: Any?
    , treatNullAsMissing: Boolean?
): Field<Any?> {
    val f = Locf()
    f.setValue(value)
    f.setPrev(prev)
    f.setTreatNullAsMissing(treatNullAsMissing)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun locf(
      value: Field<Any?>
    , prev: Field<Any?>
    , treatNullAsMissing: Field<Boolean?>
): Field<Any?> {
    val f = Locf()
    f.setValue(value)
    f.setPrev(prev)
    f.setTreatNullAsMissing(treatNullAsMissing)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun moveChunk(
      configuration: Configuration
    , chunk: Any?
    , destinationTablespace: String?
    , indexDestinationTablespace: String?
    , reorderIndex: Any?
    , verbose: Boolean?
): Unit {
    val p = MoveChunk()
    p.setChunk(chunk)
    p.setDestinationTablespace(destinationTablespace)
    p.setIndexDestinationTablespace(indexDestinationTablespace)
    p.setReorderIndex(reorderIndex)
    p.setVerbose(verbose)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun recompressChunk(
      configuration: Configuration
    , chunk: Any?
    , ifNotCompressed: Boolean?
): Any? {
    val f = RecompressChunk()
    f.setChunk(chunk)
    f.setIfNotCompressed(ifNotCompressed)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun recompressChunk(
      chunk: Any?
    , ifNotCompressed: Boolean?
): Field<Any?> {
    val f = RecompressChunk()
    f.setChunk(chunk)
    f.setIfNotCompressed(ifNotCompressed)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun recompressChunk(
      chunk: Field<Any?>
    , ifNotCompressed: Field<Boolean?>
): Field<Any?> {
    val f = RecompressChunk()
    f.setChunk(chunk)
    f.setIfNotCompressed(ifNotCompressed)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun removeCompressionPolicy(
      configuration: Configuration
    , hypertable: Any?
    , ifExists: Boolean?
): Boolean? {
    val f = RemoveCompressionPolicy()
    f.setHypertable(hypertable)
    f.setIfExists(ifExists)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun removeCompressionPolicy(
      hypertable: Any?
    , ifExists: Boolean?
): Field<Boolean?> {
    val f = RemoveCompressionPolicy()
    f.setHypertable(hypertable)
    f.setIfExists(ifExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun removeCompressionPolicy(
      hypertable: Field<Any?>
    , ifExists: Field<Boolean?>
): Field<Boolean?> {
    val f = RemoveCompressionPolicy()
    f.setHypertable(hypertable)
    f.setIfExists(ifExists)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun removeContinuousAggregatePolicy(
      configuration: Configuration
    , continuousAggregate: Any?
    , ifNotExists: Boolean?
): Unit {
    val p = RemoveContinuousAggregatePolicy()
    p.setContinuousAggregate(continuousAggregate)
    p.setIfNotExists(ifNotExists)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun removeReorderPolicy(
      configuration: Configuration
    , hypertable: Any?
    , ifExists: Boolean?
): Unit {
    val p = RemoveReorderPolicy()
    p.setHypertable(hypertable)
    p.setIfExists(ifExists)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun removeRetentionPolicy(
      configuration: Configuration
    , relation: Any?
    , ifExists: Boolean?
): Unit {
    val p = RemoveRetentionPolicy()
    p.setRelation(relation)
    p.setIfExists(ifExists)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun reorderChunk(
      configuration: Configuration
    , chunk: Any?
    , index: Any?
    , verbose: Boolean?
): Unit {
    val p = ReorderChunk()
    p.setChunk(chunk)
    p.setIndex(index)
    p.setVerbose(verbose)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun setAdaptiveChunking(
      configuration: Configuration
    , hypertable: Any?
    , chunkTargetSize: String?
    , chunkSizingFunc: String?
): SetAdaptiveChunking {
    val p = SetAdaptiveChunking()
    p.setHypertable(hypertable)
    p.setChunkTargetSize2(chunkTargetSize)
    p.setChunkSizingFunc(chunkSizingFunc)

    p.execute(configuration)
    return p
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun setChunkTimeInterval(
      configuration: Configuration
    , hypertable: Any?
    , chunkTimeInterval: Any?
    , dimensionName: String?
): Unit {
    val p = SetChunkTimeInterval()
    p.setHypertable(hypertable)
    p.setChunkTimeInterval(chunkTimeInterval)
    p.setDimensionName(dimensionName)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun setIntegerNowFunc(
      configuration: Configuration
    , hypertable: Any?
    , integerNowFunc: String?
    , replaceIfExists: Boolean?
): Unit {
    val p = SetIntegerNowFunc()
    p.setHypertable(hypertable)
    p.setIntegerNowFunc(integerNowFunc)
    p.setReplaceIfExists(replaceIfExists)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun setNumberPartitions(
      configuration: Configuration
    , hypertable: Any?
    , numberPartitions: Int?
    , dimensionName: String?
): Unit {
    val p = SetNumberPartitions()
    p.setHypertable(hypertable)
    p.setNumberPartitions(numberPartitions)
    p.setDimensionName(dimensionName)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun setReplicationFactor(
      configuration: Configuration
    , hypertable: Any?
    , replicationFactor: Int?
): Unit {
    val p = SetReplicationFactor()
    p.setHypertable(hypertable)
    p.setReplicationFactor(replicationFactor)

    p.execute(configuration)
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket1(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDateTime?
): LocalDateTime? {
    val f = TimeBucket1()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket1(
      bucketWidth: YearToSecond?
    , ts: LocalDateTime?
): Field<LocalDateTime?> {
    val f = TimeBucket1()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket1(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDateTime?>
): Field<LocalDateTime?> {
    val f = TimeBucket1()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket10(
      configuration: Configuration
    , bucketWidth: Short?
    , ts: Short?
    , offset: Short?
): Short? {
    val f = TimeBucket10()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket10(
      bucketWidth: Short?
    , ts: Short?
    , offset: Short?
): Field<Short?> {
    val f = TimeBucket10()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket10(
      bucketWidth: Field<Short?>
    , ts: Field<Short?>
    , offset: Field<Short?>
): Field<Short?> {
    val f = TimeBucket10()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket11(
      configuration: Configuration
    , bucketWidth: Int?
    , ts: Int?
    , offset: Int?
): Int? {
    val f = TimeBucket11()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket11(
      bucketWidth: Int?
    , ts: Int?
    , offset: Int?
): Field<Int?> {
    val f = TimeBucket11()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket11(
      bucketWidth: Field<Int?>
    , ts: Field<Int?>
    , offset: Field<Int?>
): Field<Int?> {
    val f = TimeBucket11()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket12(
      configuration: Configuration
    , bucketWidth: Long?
    , ts: Long?
    , offset: Long?
): Long? {
    val f = TimeBucket12()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket12(
      bucketWidth: Long?
    , ts: Long?
    , offset: Long?
): Field<Long?> {
    val f = TimeBucket12()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket12(
      bucketWidth: Field<Long?>
    , ts: Field<Long?>
    , offset: Field<Long?>
): Field<Long?> {
    val f = TimeBucket12()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket13(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDateTime?
    , offset: YearToSecond?
): LocalDateTime? {
    val f = TimeBucket13()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket13(
      bucketWidth: YearToSecond?
    , ts: LocalDateTime?
    , offset: YearToSecond?
): Field<LocalDateTime?> {
    val f = TimeBucket13()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket13(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDateTime?>
    , offset: Field<YearToSecond?>
): Field<LocalDateTime?> {
    val f = TimeBucket13()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket14(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
    , offset: YearToSecond?
): OffsetDateTime? {
    val f = TimeBucket14()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket14(
      bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
    , offset: YearToSecond?
): Field<OffsetDateTime?> {
    val f = TimeBucket14()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket14(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<OffsetDateTime?>
    , offset: Field<YearToSecond?>
): Field<OffsetDateTime?> {
    val f = TimeBucket14()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket15(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDate?
    , offset: YearToSecond?
): LocalDate? {
    val f = TimeBucket15()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket15(
      bucketWidth: YearToSecond?
    , ts: LocalDate?
    , offset: YearToSecond?
): Field<LocalDate?> {
    val f = TimeBucket15()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket15(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDate?>
    , offset: Field<YearToSecond?>
): Field<LocalDate?> {
    val f = TimeBucket15()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOffset(offset)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket2(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
): OffsetDateTime? {
    val f = TimeBucket2()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket2(
      bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
): Field<OffsetDateTime?> {
    val f = TimeBucket2()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket2(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<OffsetDateTime?>
): Field<OffsetDateTime?> {
    val f = TimeBucket2()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket3(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDate?
): LocalDate? {
    val f = TimeBucket3()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket3(
      bucketWidth: YearToSecond?
    , ts: LocalDate?
): Field<LocalDate?> {
    val f = TimeBucket3()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket3(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDate?>
): Field<LocalDate?> {
    val f = TimeBucket3()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket4(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDateTime?
    , origin: LocalDateTime?
): LocalDateTime? {
    val f = TimeBucket4()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket4(
      bucketWidth: YearToSecond?
    , ts: LocalDateTime?
    , origin: LocalDateTime?
): Field<LocalDateTime?> {
    val f = TimeBucket4()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket4(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDateTime?>
    , origin: Field<LocalDateTime?>
): Field<LocalDateTime?> {
    val f = TimeBucket4()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket5(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
    , origin: OffsetDateTime?
): OffsetDateTime? {
    val f = TimeBucket5()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket5(
      bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
    , origin: OffsetDateTime?
): Field<OffsetDateTime?> {
    val f = TimeBucket5()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket5(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<OffsetDateTime?>
    , origin: Field<OffsetDateTime?>
): Field<OffsetDateTime?> {
    val f = TimeBucket5()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket6(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDate?
    , origin: LocalDate?
): LocalDate? {
    val f = TimeBucket6()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket6(
      bucketWidth: YearToSecond?
    , ts: LocalDate?
    , origin: LocalDate?
): Field<LocalDate?> {
    val f = TimeBucket6()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket6(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDate?>
    , origin: Field<LocalDate?>
): Field<LocalDate?> {
    val f = TimeBucket6()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setOrigin(origin)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket7(
      configuration: Configuration
    , bucketWidth: Short?
    , ts: Short?
): Short? {
    val f = TimeBucket7()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket7(
      bucketWidth: Short?
    , ts: Short?
): Field<Short?> {
    val f = TimeBucket7()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket7(
      bucketWidth: Field<Short?>
    , ts: Field<Short?>
): Field<Short?> {
    val f = TimeBucket7()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket8(
      configuration: Configuration
    , bucketWidth: Int?
    , ts: Int?
): Int? {
    val f = TimeBucket8()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket8(
      bucketWidth: Int?
    , ts: Int?
): Field<Int?> {
    val f = TimeBucket8()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket8(
      bucketWidth: Field<Int?>
    , ts: Field<Int?>
): Field<Int?> {
    val f = TimeBucket8()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Call <code>public.time_bucket</code>
 */
fun timeBucket9(
      configuration: Configuration
    , bucketWidth: Long?
    , ts: Long?
): Long? {
    val f = TimeBucket9()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket9(
      bucketWidth: Long?
    , ts: Long?
): Field<Long?> {
    val f = TimeBucket9()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Get <code>public.time_bucket</code> as a field.
 */
fun timeBucket9(
      bucketWidth: Field<Long?>
    , ts: Field<Long?>
): Field<Long?> {
    val f = TimeBucket9()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)

    return f.asField()
}

/**
 * Call <code>public.time_bucket_gapfill</code>
 */
fun timeBucketGapfill1(
      configuration: Configuration
    , bucketWidth: Short?
    , ts: Short?
    , start: Short?
    , finish: Short?
): Short? {
    val f = TimeBucketGapfill1()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill1(
      bucketWidth: Short?
    , ts: Short?
    , start: Short?
    , finish: Short?
): Field<Short?> {
    val f = TimeBucketGapfill1()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill1(
      bucketWidth: Field<Short?>
    , ts: Field<Short?>
    , start: Field<Short?>
    , finish: Field<Short?>
): Field<Short?> {
    val f = TimeBucketGapfill1()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Call <code>public.time_bucket_gapfill</code>
 */
fun timeBucketGapfill2(
      configuration: Configuration
    , bucketWidth: Int?
    , ts: Int?
    , start: Int?
    , finish: Int?
): Int? {
    val f = TimeBucketGapfill2()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill2(
      bucketWidth: Int?
    , ts: Int?
    , start: Int?
    , finish: Int?
): Field<Int?> {
    val f = TimeBucketGapfill2()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill2(
      bucketWidth: Field<Int?>
    , ts: Field<Int?>
    , start: Field<Int?>
    , finish: Field<Int?>
): Field<Int?> {
    val f = TimeBucketGapfill2()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Call <code>public.time_bucket_gapfill</code>
 */
fun timeBucketGapfill3(
      configuration: Configuration
    , bucketWidth: Long?
    , ts: Long?
    , start: Long?
    , finish: Long?
): Long? {
    val f = TimeBucketGapfill3()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill3(
      bucketWidth: Long?
    , ts: Long?
    , start: Long?
    , finish: Long?
): Field<Long?> {
    val f = TimeBucketGapfill3()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill3(
      bucketWidth: Field<Long?>
    , ts: Field<Long?>
    , start: Field<Long?>
    , finish: Field<Long?>
): Field<Long?> {
    val f = TimeBucketGapfill3()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Call <code>public.time_bucket_gapfill</code>
 */
fun timeBucketGapfill4(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDate?
    , start: LocalDate?
    , finish: LocalDate?
): LocalDate? {
    val f = TimeBucketGapfill4()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill4(
      bucketWidth: YearToSecond?
    , ts: LocalDate?
    , start: LocalDate?
    , finish: LocalDate?
): Field<LocalDate?> {
    val f = TimeBucketGapfill4()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill4(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDate?>
    , start: Field<LocalDate?>
    , finish: Field<LocalDate?>
): Field<LocalDate?> {
    val f = TimeBucketGapfill4()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Call <code>public.time_bucket_gapfill</code>
 */
fun timeBucketGapfill5(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: LocalDateTime?
    , start: LocalDateTime?
    , finish: LocalDateTime?
): LocalDateTime? {
    val f = TimeBucketGapfill5()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill5(
      bucketWidth: YearToSecond?
    , ts: LocalDateTime?
    , start: LocalDateTime?
    , finish: LocalDateTime?
): Field<LocalDateTime?> {
    val f = TimeBucketGapfill5()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill5(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<LocalDateTime?>
    , start: Field<LocalDateTime?>
    , finish: Field<LocalDateTime?>
): Field<LocalDateTime?> {
    val f = TimeBucketGapfill5()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Call <code>public.time_bucket_gapfill</code>
 */
fun timeBucketGapfill6(
      configuration: Configuration
    , bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
    , start: OffsetDateTime?
    , finish: OffsetDateTime?
): OffsetDateTime? {
    val f = TimeBucketGapfill6()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill6(
      bucketWidth: YearToSecond?
    , ts: OffsetDateTime?
    , start: OffsetDateTime?
    , finish: OffsetDateTime?
): Field<OffsetDateTime?> {
    val f = TimeBucketGapfill6()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}

/**
 * Get <code>public.time_bucket_gapfill</code> as a field.
 */
fun timeBucketGapfill6(
      bucketWidth: Field<YearToSecond?>
    , ts: Field<OffsetDateTime?>
    , start: Field<OffsetDateTime?>
    , finish: Field<OffsetDateTime?>
): Field<OffsetDateTime?> {
    val f = TimeBucketGapfill6()
    f.setBucketWidth(bucketWidth)
    f.setTs(ts)
    f.setStart(start)
    f.setFinish(finish)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun timescaledbFdwHandler(
      configuration: Configuration
): Any? {
    val f = TimescaledbFdwHandler()

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun timescaledbFdwHandler(): Field<Any?> {
    val f = TimescaledbFdwHandler()

    return f.asField()
}

/**
 * Call <code>public.timescaledb_fdw_validator</code>
 */
fun timescaledbFdwValidator(
      configuration: Configuration
    , __1: Array<String?>?
    , __2: Long?
): Unit {
    val p = TimescaledbFdwValidator()
    p.set__1(__1)
    p.set__2(__2)

    p.execute(configuration)
}

/**
 * Call <code>public.timescaledb_post_restore</code>
 */
fun timescaledbPostRestore(
      configuration: Configuration
): Boolean? {
    val f = TimescaledbPostRestore()

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.timescaledb_post_restore</code> as a field.
 */
fun timescaledbPostRestore(): Field<Boolean?> {
    val f = TimescaledbPostRestore()

    return f.asField()
}

/**
 * Call <code>public.timescaledb_pre_restore</code>
 */
fun timescaledbPreRestore(
      configuration: Configuration
): Boolean? {
    val f = TimescaledbPreRestore()

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.timescaledb_pre_restore</code> as a field.
 */
fun timescaledbPreRestore(): Field<Boolean?> {
    val f = TimescaledbPreRestore()

    return f.asField()
}

/**
 * Call <code>public.add_data_node</code>.
 */
fun addDataNode(
      configuration: Configuration
    , nodeName: String?
    , host: String?
    , database: String?
    , port: Int?
    , ifNotExists: Boolean?
    , bootstrap: Boolean?
    , password: String?
): Result<AddDataNodeRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.AddDataNode.ADD_DATA_NODE.call(
      nodeName
    , host
    , database
    , port
    , ifNotExists
    , bootstrap
    , password
)).fetch()

/**
 * Get <code>public.add_data_node</code> as a table.
 */
fun addDataNode(
      nodeName: String?
    , host: String?
    , database: String?
    , port: Int?
    , ifNotExists: Boolean?
    , bootstrap: Boolean?
    , password: String?
): AddDataNode = me.sumit.uptime.database.generated.tables.AddDataNode.ADD_DATA_NODE.call(
      nodeName
    , host
    , database
    , port
    , ifNotExists
    , bootstrap
    , password
)

/**
 * Get <code>public.add_data_node</code> as a table.
 */
fun addDataNode(
      nodeName: Field<String?>
    , host: Field<String?>
    , database: Field<String?>
    , port: Field<Int?>
    , ifNotExists: Field<Boolean?>
    , bootstrap: Field<Boolean?>
    , password: Field<String?>
): AddDataNode = me.sumit.uptime.database.generated.tables.AddDataNode.ADD_DATA_NODE.call(
      nodeName
    , host
    , database
    , port
    , ifNotExists
    , bootstrap
    , password
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addDimension(
      configuration: Configuration
    , hypertable: Any?
    , columnName: String?
    , numberPartitions: Int?
    , chunkTimeInterval: Any?
    , partitioningFunc: String?
    , ifNotExists: Boolean?
): Result<AddDimensionRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.AddDimension.ADD_DIMENSION.call(
      hypertable
    , columnName
    , numberPartitions
    , chunkTimeInterval
    , partitioningFunc
    , ifNotExists
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addDimension(
      hypertable: Any?
    , columnName: String?
    , numberPartitions: Int?
    , chunkTimeInterval: Any?
    , partitioningFunc: String?
    , ifNotExists: Boolean?
): AddDimension = me.sumit.uptime.database.generated.tables.AddDimension.ADD_DIMENSION.call(
      hypertable
    , columnName
    , numberPartitions
    , chunkTimeInterval
    , partitioningFunc
    , ifNotExists
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun addDimension(
      hypertable: Field<Any?>
    , columnName: Field<String?>
    , numberPartitions: Field<Int?>
    , chunkTimeInterval: Field<Any?>
    , partitioningFunc: Field<String?>
    , ifNotExists: Field<Boolean?>
): AddDimension = me.sumit.uptime.database.generated.tables.AddDimension.ADD_DIMENSION.call(
      hypertable
    , columnName
    , numberPartitions
    , chunkTimeInterval
    , partitioningFunc
    , ifNotExists
)

/**
 * Call <code>public.alter_job</code>.
 */
fun alterJob(
      configuration: Configuration
    , jobId: Int?
    , scheduleInterval: YearToSecond?
    , maxRuntime: YearToSecond?
    , maxRetries: Int?
    , retryPeriod: YearToSecond?
    , scheduled: Boolean?
    , config: String?
    , nextStart: OffsetDateTime?
    , ifExists: Boolean?
): Result<AlterJobRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.AlterJob.ALTER_JOB.call(
      jobId
    , scheduleInterval
    , maxRuntime
    , maxRetries
    , retryPeriod
    , scheduled
    , config
    , nextStart
    , ifExists
)).fetch()

/**
 * Get <code>public.alter_job</code> as a table.
 */
fun alterJob(
      jobId: Int?
    , scheduleInterval: YearToSecond?
    , maxRuntime: YearToSecond?
    , maxRetries: Int?
    , retryPeriod: YearToSecond?
    , scheduled: Boolean?
    , config: String?
    , nextStart: OffsetDateTime?
    , ifExists: Boolean?
): AlterJob = me.sumit.uptime.database.generated.tables.AlterJob.ALTER_JOB.call(
      jobId
    , scheduleInterval
    , maxRuntime
    , maxRetries
    , retryPeriod
    , scheduled
    , config
    , nextStart
    , ifExists
)

/**
 * Get <code>public.alter_job</code> as a table.
 */
fun alterJob(
      jobId: Field<Int?>
    , scheduleInterval: Field<YearToSecond?>
    , maxRuntime: Field<YearToSecond?>
    , maxRetries: Field<Int?>
    , retryPeriod: Field<YearToSecond?>
    , scheduled: Field<Boolean?>
    , config: Field<String?>
    , nextStart: Field<OffsetDateTime?>
    , ifExists: Field<Boolean?>
): AlterJob = me.sumit.uptime.database.generated.tables.AlterJob.ALTER_JOB.call(
      jobId
    , scheduleInterval
    , maxRuntime
    , maxRetries
    , retryPeriod
    , scheduled
    , config
    , nextStart
    , ifExists
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun attachDataNode(
      configuration: Configuration
    , nodeName: String?
    , hypertable: Any?
    , ifNotAttached: Boolean?
    , repartition: Boolean?
): Result<AttachDataNodeRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.AttachDataNode.ATTACH_DATA_NODE.call(
      nodeName
    , hypertable
    , ifNotAttached
    , repartition
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun attachDataNode(
      nodeName: String?
    , hypertable: Any?
    , ifNotAttached: Boolean?
    , repartition: Boolean?
): AttachDataNode = me.sumit.uptime.database.generated.tables.AttachDataNode.ATTACH_DATA_NODE.call(
      nodeName
    , hypertable
    , ifNotAttached
    , repartition
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun attachDataNode(
      nodeName: Field<String?>
    , hypertable: Field<Any?>
    , ifNotAttached: Field<Boolean?>
    , repartition: Field<Boolean?>
): AttachDataNode = me.sumit.uptime.database.generated.tables.AttachDataNode.ATTACH_DATA_NODE.call(
      nodeName
    , hypertable
    , ifNotAttached
    , repartition
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun chunkCompressionStats(
      configuration: Configuration
    , hypertable: Any?
): Result<ChunkCompressionStatsRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.ChunkCompressionStats.CHUNK_COMPRESSION_STATS.call(
      hypertable
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun chunkCompressionStats(
      hypertable: Any?
): ChunkCompressionStats = me.sumit.uptime.database.generated.tables.ChunkCompressionStats.CHUNK_COMPRESSION_STATS.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun chunkCompressionStats(
      hypertable: Field<Any?>
): ChunkCompressionStats = me.sumit.uptime.database.generated.tables.ChunkCompressionStats.CHUNK_COMPRESSION_STATS.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun chunksDetailedSize(
      configuration: Configuration
    , hypertable: Any?
): Result<ChunksDetailedSizeRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.ChunksDetailedSize.CHUNKS_DETAILED_SIZE.call(
      hypertable
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun chunksDetailedSize(
      hypertable: Any?
): ChunksDetailedSize = me.sumit.uptime.database.generated.tables.ChunksDetailedSize.CHUNKS_DETAILED_SIZE.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun chunksDetailedSize(
      hypertable: Field<Any?>
): ChunksDetailedSize = me.sumit.uptime.database.generated.tables.ChunksDetailedSize.CHUNKS_DETAILED_SIZE.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun createDistributedHypertable(
      configuration: Configuration
    , relation: Any?
    , timeColumnName: String?
    , partitioningColumn: String?
    , numberPartitions: Int?
    , associatedSchemaName: String?
    , associatedTablePrefix: String?
    , chunkTimeInterval: Any?
    , createDefaultIndexes: Boolean?
    , ifNotExists: Boolean?
    , partitioningFunc: String?
    , migrateData: Boolean?
    , chunkTargetSize: String?
    , chunkSizingFunc: String?
    , timePartitioningFunc: String?
    , replicationFactor: Int?
    , dataNodes: Array<String?>?
): Result<CreateDistributedHypertableRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.CreateDistributedHypertable.CREATE_DISTRIBUTED_HYPERTABLE.call(
      relation
    , timeColumnName
    , partitioningColumn
    , numberPartitions
    , associatedSchemaName
    , associatedTablePrefix
    , chunkTimeInterval
    , createDefaultIndexes
    , ifNotExists
    , partitioningFunc
    , migrateData
    , chunkTargetSize
    , chunkSizingFunc
    , timePartitioningFunc
    , replicationFactor
    , dataNodes
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun createDistributedHypertable(
      relation: Any?
    , timeColumnName: String?
    , partitioningColumn: String?
    , numberPartitions: Int?
    , associatedSchemaName: String?
    , associatedTablePrefix: String?
    , chunkTimeInterval: Any?
    , createDefaultIndexes: Boolean?
    , ifNotExists: Boolean?
    , partitioningFunc: String?
    , migrateData: Boolean?
    , chunkTargetSize: String?
    , chunkSizingFunc: String?
    , timePartitioningFunc: String?
    , replicationFactor: Int?
    , dataNodes: Array<String?>?
): CreateDistributedHypertable = me.sumit.uptime.database.generated.tables.CreateDistributedHypertable.CREATE_DISTRIBUTED_HYPERTABLE.call(
      relation
    , timeColumnName
    , partitioningColumn
    , numberPartitions
    , associatedSchemaName
    , associatedTablePrefix
    , chunkTimeInterval
    , createDefaultIndexes
    , ifNotExists
    , partitioningFunc
    , migrateData
    , chunkTargetSize
    , chunkSizingFunc
    , timePartitioningFunc
    , replicationFactor
    , dataNodes
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun createDistributedHypertable(
      relation: Field<Any?>
    , timeColumnName: Field<String?>
    , partitioningColumn: Field<String?>
    , numberPartitions: Field<Int?>
    , associatedSchemaName: Field<String?>
    , associatedTablePrefix: Field<String?>
    , chunkTimeInterval: Field<Any?>
    , createDefaultIndexes: Field<Boolean?>
    , ifNotExists: Field<Boolean?>
    , partitioningFunc: Field<String?>
    , migrateData: Field<Boolean?>
    , chunkTargetSize: Field<String?>
    , chunkSizingFunc: Field<String?>
    , timePartitioningFunc: Field<String?>
    , replicationFactor: Field<Int?>
    , dataNodes: Field<Array<String?>?>
): CreateDistributedHypertable = me.sumit.uptime.database.generated.tables.CreateDistributedHypertable.CREATE_DISTRIBUTED_HYPERTABLE.call(
      relation
    , timeColumnName
    , partitioningColumn
    , numberPartitions
    , associatedSchemaName
    , associatedTablePrefix
    , chunkTimeInterval
    , createDefaultIndexes
    , ifNotExists
    , partitioningFunc
    , migrateData
    , chunkTargetSize
    , chunkSizingFunc
    , timePartitioningFunc
    , replicationFactor
    , dataNodes
)

/**
 * Call <code>public.create_distributed_restore_point</code>.
 */
fun createDistributedRestorePoint(
      configuration: Configuration
    , name: String?
): Result<CreateDistributedRestorePointRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.CreateDistributedRestorePoint.CREATE_DISTRIBUTED_RESTORE_POINT.call(
      name
)).fetch()

/**
 * Get <code>public.create_distributed_restore_point</code> as a table.
 */
fun createDistributedRestorePoint(
      name: String?
): CreateDistributedRestorePoint = me.sumit.uptime.database.generated.tables.CreateDistributedRestorePoint.CREATE_DISTRIBUTED_RESTORE_POINT.call(
      name
)

/**
 * Get <code>public.create_distributed_restore_point</code> as a table.
 */
fun createDistributedRestorePoint(
      name: Field<String?>
): CreateDistributedRestorePoint = me.sumit.uptime.database.generated.tables.CreateDistributedRestorePoint.CREATE_DISTRIBUTED_RESTORE_POINT.call(
      name
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun createHypertable(
      configuration: Configuration
    , relation: Any?
    , timeColumnName: String?
    , partitioningColumn: String?
    , numberPartitions: Int?
    , associatedSchemaName: String?
    , associatedTablePrefix: String?
    , chunkTimeInterval: Any?
    , createDefaultIndexes: Boolean?
    , ifNotExists: Boolean?
    , partitioningFunc: String?
    , migrateData: Boolean?
    , chunkTargetSize: String?
    , chunkSizingFunc: String?
    , timePartitioningFunc: String?
    , replicationFactor: Int?
    , dataNodes: Array<String?>?
): Result<CreateHypertableRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.CreateHypertable.CREATE_HYPERTABLE.call(
      relation
    , timeColumnName
    , partitioningColumn
    , numberPartitions
    , associatedSchemaName
    , associatedTablePrefix
    , chunkTimeInterval
    , createDefaultIndexes
    , ifNotExists
    , partitioningFunc
    , migrateData
    , chunkTargetSize
    , chunkSizingFunc
    , timePartitioningFunc
    , replicationFactor
    , dataNodes
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun createHypertable(
      relation: Any?
    , timeColumnName: String?
    , partitioningColumn: String?
    , numberPartitions: Int?
    , associatedSchemaName: String?
    , associatedTablePrefix: String?
    , chunkTimeInterval: Any?
    , createDefaultIndexes: Boolean?
    , ifNotExists: Boolean?
    , partitioningFunc: String?
    , migrateData: Boolean?
    , chunkTargetSize: String?
    , chunkSizingFunc: String?
    , timePartitioningFunc: String?
    , replicationFactor: Int?
    , dataNodes: Array<String?>?
): CreateHypertable = me.sumit.uptime.database.generated.tables.CreateHypertable.CREATE_HYPERTABLE.call(
      relation
    , timeColumnName
    , partitioningColumn
    , numberPartitions
    , associatedSchemaName
    , associatedTablePrefix
    , chunkTimeInterval
    , createDefaultIndexes
    , ifNotExists
    , partitioningFunc
    , migrateData
    , chunkTargetSize
    , chunkSizingFunc
    , timePartitioningFunc
    , replicationFactor
    , dataNodes
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun createHypertable(
      relation: Field<Any?>
    , timeColumnName: Field<String?>
    , partitioningColumn: Field<String?>
    , numberPartitions: Field<Int?>
    , associatedSchemaName: Field<String?>
    , associatedTablePrefix: Field<String?>
    , chunkTimeInterval: Field<Any?>
    , createDefaultIndexes: Field<Boolean?>
    , ifNotExists: Field<Boolean?>
    , partitioningFunc: Field<String?>
    , migrateData: Field<Boolean?>
    , chunkTargetSize: Field<String?>
    , chunkSizingFunc: Field<String?>
    , timePartitioningFunc: Field<String?>
    , replicationFactor: Field<Int?>
    , dataNodes: Field<Array<String?>?>
): CreateHypertable = me.sumit.uptime.database.generated.tables.CreateHypertable.CREATE_HYPERTABLE.call(
      relation
    , timeColumnName
    , partitioningColumn
    , numberPartitions
    , associatedSchemaName
    , associatedTablePrefix
    , chunkTimeInterval
    , createDefaultIndexes
    , ifNotExists
    , partitioningFunc
    , migrateData
    , chunkTargetSize
    , chunkSizingFunc
    , timePartitioningFunc
    , replicationFactor
    , dataNodes
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun dropChunks(
      configuration: Configuration
    , relation: Any?
    , olderThan: Any?
    , newerThan: Any?
    , verbose: Boolean?
): Result<DropChunksRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.DropChunks.DROP_CHUNKS.call(
      relation
    , olderThan
    , newerThan
    , verbose
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun dropChunks(
      relation: Any?
    , olderThan: Any?
    , newerThan: Any?
    , verbose: Boolean?
): DropChunks = me.sumit.uptime.database.generated.tables.DropChunks.DROP_CHUNKS.call(
      relation
    , olderThan
    , newerThan
    , verbose
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun dropChunks(
      relation: Field<Any?>
    , olderThan: Field<Any?>
    , newerThan: Field<Any?>
    , verbose: Field<Boolean?>
): DropChunks = me.sumit.uptime.database.generated.tables.DropChunks.DROP_CHUNKS.call(
      relation
    , olderThan
    , newerThan
    , verbose
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableCompressionStats(
      configuration: Configuration
    , hypertable: Any?
): Result<HypertableCompressionStatsRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.HypertableCompressionStats.HYPERTABLE_COMPRESSION_STATS.call(
      hypertable
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableCompressionStats(
      hypertable: Any?
): HypertableCompressionStats = me.sumit.uptime.database.generated.tables.HypertableCompressionStats.HYPERTABLE_COMPRESSION_STATS.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableCompressionStats(
      hypertable: Field<Any?>
): HypertableCompressionStats = me.sumit.uptime.database.generated.tables.HypertableCompressionStats.HYPERTABLE_COMPRESSION_STATS.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableDetailedSize(
      configuration: Configuration
    , hypertable: Any?
): Result<HypertableDetailedSizeRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.HypertableDetailedSize.HYPERTABLE_DETAILED_SIZE.call(
      hypertable
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableDetailedSize(
      hypertable: Any?
): HypertableDetailedSize = me.sumit.uptime.database.generated.tables.HypertableDetailedSize.HYPERTABLE_DETAILED_SIZE.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun hypertableDetailedSize(
      hypertable: Field<Any?>
): HypertableDetailedSize = me.sumit.uptime.database.generated.tables.HypertableDetailedSize.HYPERTABLE_DETAILED_SIZE.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun showChunks(
      configuration: Configuration
    , relation: Any?
    , olderThan: Any?
    , newerThan: Any?
): Result<ShowChunksRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.ShowChunks.SHOW_CHUNKS.call(
      relation
    , olderThan
    , newerThan
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun showChunks(
      relation: Any?
    , olderThan: Any?
    , newerThan: Any?
): ShowChunks = me.sumit.uptime.database.generated.tables.ShowChunks.SHOW_CHUNKS.call(
      relation
    , olderThan
    , newerThan
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun showChunks(
      relation: Field<Any?>
    , olderThan: Field<Any?>
    , newerThan: Field<Any?>
): ShowChunks = me.sumit.uptime.database.generated.tables.ShowChunks.SHOW_CHUNKS.call(
      relation
    , olderThan
    , newerThan
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun showTablespaces(
      configuration: Configuration
    , hypertable: Any?
): Result<ShowTablespacesRecord> = configuration.dsl().selectFrom(me.sumit.uptime.database.generated.tables.ShowTablespaces.SHOW_TABLESPACES.call(
      hypertable
)).fetch()
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun showTablespaces(
      hypertable: Any?
): ShowTablespaces = me.sumit.uptime.database.generated.tables.ShowTablespaces.SHOW_TABLESPACES.call(
      hypertable
)
@Deprecated(message = "Unknown data type. Please define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun showTablespaces(
      hypertable: Field<Any?>
): ShowTablespaces = me.sumit.uptime.database.generated.tables.ShowTablespaces.SHOW_TABLESPACES.call(
      hypertable
)
